This is the section where I will be explaining how the math behind this works.

First of all, an adjacency matrix. It's a matrix which shows the relation between nodes using a matrix. If there is any realtion from i'th node to j'th node, then we put 1 at j'th row and i'th column. If there is no relation, we put 0. Now, what' so special about them? Their powers. If we raise a matrix to 2nd power, we will get a matrix which shows us the number of ways to get to j from i in two steps. Same is true for all the next powers. That is what we need.

How do we check all matrices? Well, there are total of 2^(n*n) matrices for nxn matrix because we only want elements to be 0 or 1. If we just turn all these numbers into matrices, we can get all matrices. It's actually easy to do. We just have to get the binary representaton of a number and add zeros at beginning. This will get us a string. Use this string and start filling the matrix with those numbers. Now, this is the part which is quite expensive in term of time. I have optimized it but I think there are faster ways to do same thing.

Now, we want a matrix which get us to the j'th node in a some steps. For that, what we need is a way to get from any node to j. Which means, the jth row should be completely filled. If there is any column which is empty, it will remain empty after any number of steps as there is no way to get there. So, all columns should have at least one value.

If there is any element in another row, then it means that there is some way to get there at given step. We want all the paths to lead us at only one point. So, we want only one row to have any numbers. That way, all paths will have to come at same place.

We dont have to use numbers. To be honest, we just want to know if there is any way to get from all nodes to j'th node. We dont care about the number of ways it can do that. Here, we can replace all the numbers with True and False. But how will we do matrix multiplication? We will just replace the arithmetic operations with logical operators. Multiplicaton is same as AND operator. 0x0=0, 0x1=0, 1x0=0 and 1x1=1. Both of them work the same way. For Additon, we will replace it with OR operator. If any value is True, then given value will be more than 1 as there are no negative numbers. There are some weird but efficient ways to do this faster, which I'll discuss later.

If you have seen a matrix multiplication, you will notice that the diagonal elements multiply with themselves. Well,  if that element was True, it will give out True value everytime. Logically speaking, if there is a way to get from j'th node back to itself in one step, we can keep doing it and not go anywhere else. If there are 2 such nodes, then they will keep going into themselves and we will never get all of them at same point. For this, we have to make sure that given matrix doesnt have more than 1 True values on diagonal.

Imagine that there are two nodes which go into each other. On each step, first goes into second and second goes into first. On next, they go back. This way, they get stuck. To avoid this, make sure that if there is True at (j,i) then there are none at (i,j)

/ A bit weird optimizatons.
For matrix multiplication, we are using logical operators. But it can be faster with sets. I know it sounds weird but hear me out. We are mutiplying our base matrix each time while going through a loop. So, we can take a column and make a set which row number of all True values in given column. We do this for all columns. Now, during matrix multiplication, when we are going through a row of first matrix, we can make a set which contains the column number of all the True values in given row. In matrix multiplication, you go through j'th row of first matrix and i'th column of second matrx and if there are True values at j'th row and k'th column of first matrix and k'th row and i'th column of second(base) matrix then their multiplication or AND operation will give is True value. Whih mean, if there is any intersection between first matrix's j'th row's set and second matrix's i'th column's set then we can say both have some k values which are same and thus j'th row and i'th column of resultant matrix is True.
It's a bit hard to understand but if you look at code and try to understand I think it'll make sense. I think.

If you add value of n manually at line 37, you can save some time. Whenever you put a variable somewhere in a function, python first looks at local variables and if it cant fnd anythiing there, then it moves on to find it in global variables. This takes up a bit of time, it's in milliseconds but if you are running it on large scale, it can make code a little faster.
