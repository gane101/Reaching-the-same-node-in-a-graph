This is the section where I will be explaining how the math behind works.

First of all, an adjacency matrix. It's a matrix which shows the relation between nodes using a matrix. If there is any realtion from i'th node to j'th node, then we put 1 at j'th row and i'th column. If there is no relation, we put 0. Now, what' so special about them? Their powers. If we raise a matrix to 2nd power, we will get a matrix which shows us the number of ways to get to j from i. That is what we need.

How do we check all matrices? Well, there are total of 2^(n*n) matrices for nxn matrix. If we just turn all these numbers into matrices, we can get all matrices. It's actually easy to do. We just have to get the binary representaton of a number and add zeros at beggning. This will get us a string. Use this string and start filling the matrix with those numbers. Now, this is the part which is quite expensive in term of time. I have optimized it but I think there are faster ways to do same thing.

Now, we want a matrix which get us to the j'th node in a some steps. For that, what we need is a way to get from any node to j. Which mean, the jth row should be completely filled. If there is any column which is empty, it will remain empty after any number of steps as there is no way to get there. So, all columns should have at least one value.

If there is any element in another row, then it means that there is some way to get there at given step. We want all the paths to lead us at only one point. So, we want only one row to have any numbers. That way, all paths will have to come at same place.

We dont have to use numbers. To be honest, we just want to know if there is any way to get from all nodes to j'th node. We dont care about the number of ways it can do so. Here, we can replace all the numbers with True and false. But how will we do matrix multiplication? We will just replace the arithmetic operations with logical operators. Multiplicaton is same as AND operator. 0*0=0, 0*1=0, 1*0=0 and 1*1=1. Both of them work the same way. For Additon, we will replace it with OR operator. If any value is True, then given value will be more than 1 as there are no negative numbers. There are some weird but efficient ways to do this faster, which I'll discuss later.

If you have seen a matrix multiplication, you will notice that the diagonal elements multiply with themselves. Well, imagne if that element was True. It will gve out True everytime. Logically speaking, if there s a way to get from j'th node back to itself in one step, we can keep doing it and not go anywhere else. If ther are 2 such numbers, then they will keep going into themselves and we will never get all of them at same point. For this, we have to make sure that given matrix doesnt have more than 1 True values.

/ A bit weird optimizatons.
For matrix multiplication, we are using logical operators. But it can be faster with sets. I know it sounds weird but hear me out. We are mutiplying our base matrix each time. So, we can take a column and make a set which contains number of rows which are True. We do this for all columns. Now, during matrix multiplication, when we are going through a row of first matrix, we can make a set which contains the column number of all the True values in given row. In matrix multiplication, you go through j'th row of first matrix and i'th column of second and if there are True values at j'th row and k'th column of first matrix and k'th row and i'th column of second(base) matrix then their multiplication or AND operation will give is True value. Whih mean, if there is any intersection between first matrix's j'th row's set and second matrix's i'th column's set then we can say both have some k values which are same and thus given number is True.
It's a bit hard to understand but If you look at code and try to understand I think it'll make sense. I think.
